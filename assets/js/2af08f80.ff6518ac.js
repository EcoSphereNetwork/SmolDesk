"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6808],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var i=s(96540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},61031:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"docs/testing/phase-4-overview","title":"Phase 4 Overview","description":"","source":"@site/docs/testing/phase-4-overview.md","sourceDirName":"docs/testing","slug":"/docs/testing/phase-4-overview","permalink":"/SmolDesk/docs/testing/phase-4-overview","draft":false,"unlisted":false,"editUrl":"https://github.com/EcoSphereNetwork/SmolDesk/edit/main/docs/docs/testing/phase-4-overview.md","tags":[],"version":"current","frontMatter":{"title":"Phase 4 Overview","description":""}}');var t=s(74848),r=s(28453);const o={title:"Phase 4 Overview",description:""},c="Phase 4 Overview",d={},a=[{value:"Goals",id:"goals",level:2},{value:"Structure",id:"structure",level:2},{value:"IPC Mocking",id:"ipc-mocking",level:2},{value:"Playwright Setup",id:"playwright-setup",level:2},{value:"WebRTC Simulation &amp; Window Control",id:"webrtc-simulation--window-control",level:3},{value:"Multi-Window Scenarios",id:"multi-window-scenarios",level:3},{value:"Snapshot Strategy",id:"snapshot-strategy",level:3},{value:"Error Paths and Offline Mode",id:"error-paths-and-offline-mode",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"phase-4-overview",children:"Phase 4 Overview"})}),"\n",(0,t.jsx)(n.p,{children:"This phase introduces a testable IPC architecture and sets up Playwright for end-to-end tests."}),"\n",(0,t.jsx)(n.h2,{id:"goals",children:"Goals"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Mock Tauri IPC APIs for unit and integration tests"}),"\n",(0,t.jsxs)(n.li,{children:["Provide a structure under ",(0,t.jsx)(n.code,{children:"src/ipc/__mocks__/"})," for these mocks"]}),"\n",(0,t.jsx)(n.li,{children:"Add Playwright to run the application in simulated windows"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"structure",children:"Structure"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"src/ipc/__mocks__/"})," \u2013 mock implementations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"src/e2e/"})," \u2013 Playwright specs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"playwright.config.ts"})," \u2013 Playwright configuration"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"ipc-mocking",children:"IPC Mocking"}),"\n",(0,t.jsxs)(n.p,{children:["The frontend loads either a mock implementation or the real Tauri API depending on the ",(0,t.jsx)(n.code,{children:"VITE_USE_MOCK"})," environment variable. The interface lives in ",(0,t.jsx)(n.code,{children:"src/ipc/interface.ts"})," and both ",(0,t.jsx)(n.code,{children:"src/ipc/tauri.ts"})," and ",(0,t.jsx)(n.code,{children:"src/ipc/__mocks__/"})," implement it."]}),"\n",(0,t.jsx)(n.h2,{id:"playwright-setup",children:"Playwright Setup"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"playwright.config.ts"})," defines a headless browser environment. Tests live under ",(0,t.jsx)(n.code,{children:"src/e2e/"})," and can be run with ",(0,t.jsx)(n.code,{children:"npm run e2e"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"webrtc-simulation--window-control",children:"WebRTC Simulation & Window Control"}),"\n",(0,t.jsx)(n.p,{children:"During unit and e2e tests, WebRTC APIs and Tauri window methods are mocked. This allows verifying UI reactions to connection states and window events without launching a real backend."}),"\n",(0,t.jsx)(n.h3,{id:"multi-window-scenarios",children:"Multi-Window Scenarios"}),"\n",(0,t.jsxs)(n.p,{children:["E2E tests switch between a main window and a settings window using mocked window\ncontrols. The navigation button uses ",(0,t.jsx)(n.code,{children:'data-testid="open-settings"'}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"snapshot-strategy",children:"Snapshot Strategy"}),"\n",(0,t.jsxs)(n.p,{children:["Playwright's ",(0,t.jsx)(n.code,{children:"toHaveScreenshot()"})," is used for basic visual regression. Generated\nimages are stored under ",(0,t.jsx)(n.code,{children:"test-results/"})," and ignored from Git."]}),"\n",(0,t.jsx)(n.h3,{id:"error-paths-and-offline-mode",children:"Error Paths and Offline Mode"}),"\n",(0,t.jsxs)(n.p,{children:["Phase 4.4 introduces dedicated mocks for failure cases and offline\nsimulation. The Playwright specs ",(0,t.jsx)(n.code,{children:"connection-error.spec.ts"})," and\n",(0,t.jsx)(n.code,{children:"offline.spec.ts"})," verify that the UI reacts gracefully when IPC calls fail or no\nnetwork is available."]}),"\n",(0,t.jsx)(n.p,{children:"Phase 4.5 finalizes snapshot handling and prepares the e2e suite for CI usage."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Status:"})," Phase 4 is complete. Further visual testing continues in Phase 5."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);