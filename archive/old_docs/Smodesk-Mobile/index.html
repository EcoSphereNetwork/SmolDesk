<!doctype html>
<html lang="de" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-archive/old_docs/Smodesk-Mobile" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">Smodesk-Mobile | SmolDesk</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://ecospherenetwork.github.io/SmolDesk/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://ecospherenetwork.github.io/SmolDesk/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://ecospherenetwork.github.io/SmolDesk/archive/old_docs/Smodesk-Mobile"><meta data-rh="true" property="og:locale" content="de"><meta data-rh="true" property="og:locale:alternate" content="en"><meta data-rh="true" name="docusaurus_locale" content="de"><meta data-rh="true" name="docsearch:language" content="de"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Smodesk-Mobile | SmolDesk"><link data-rh="true" rel="icon" href="/SmolDesk/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://ecospherenetwork.github.io/SmolDesk/archive/old_docs/Smodesk-Mobile"><link data-rh="true" rel="alternate" href="https://ecospherenetwork.github.io/SmolDesk/archive/old_docs/Smodesk-Mobile" hreflang="de"><link data-rh="true" rel="alternate" href="https://ecospherenetwork.github.io/SmolDesk/en/archive/old_docs/Smodesk-Mobile" hreflang="en"><link data-rh="true" rel="alternate" href="https://ecospherenetwork.github.io/SmolDesk/archive/old_docs/Smodesk-Mobile" hreflang="x-default"><link rel="stylesheet" href="/SmolDesk/assets/css/styles.7d1c6dde.css">
<script src="/SmolDesk/assets/js/runtime~main.356ef766.js" defer="defer"></script>
<script src="/SmolDesk/assets/js/main.b92ee36e.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/SmolDesk/img/logo.svg"><div role="region" aria-label="Zum Hauptinhalt springen"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Zum Hauptinhalt springen</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/SmolDesk/"><div class="navbar__logo"><img src="/SmolDesk/img/logo.svg" alt="SmolDesk Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/SmolDesk/img/logo.svg" alt="SmolDesk Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">ESN</b></a><a class="navbar__item navbar__link" href="/SmolDesk/docs/architecture">Documentation</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/EcoSphereNetwork/SmolDesk" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>Deutsch</a><ul class="dropdown__menu"><li><a href="/SmolDesk/archive/old_docs/Smodesk-Mobile" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="de">Deutsch</a></li><li><a href="/SmolDesk/en/archive/old_docs/Smodesk-Mobile" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en">English</a></li></ul></div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Umschalten zwischen dunkler und heller Ansicht (momentan system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Zurück nach oben scrollen" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><main class="docMainContainer_TBSr docMainContainerEnhanced_lQrH"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="theme-doc-markdown markdown"><header><h1>Smodesk-Mobile</h1></header><blockquote>
<p>⚠️ Diese Datei wurde archiviert. Die aktuelle Version befindet sich unter <code>docs/development/setup-android.md</code></p>
</blockquote>
<p>Ziel: Entwicklung einer plattformübergreifenden React Native App (Android zuerst, danach iOS) für SmolDesk, die alle Funktionen der Desktop-Version unterstützt. SmolDesk ist eine WebRTC-basierte Remote-Desktop-Lösung für Linux mit Fokus auf niedriger Latenz und Sicherheit. Die Mobile-App richtet sich an Endnutzer und soll mobile-first optimiert sein (intuitive Touch-Bedienung, responsives UI etc.). Im Folgenden ein detaillierter Schritt-für-Schritt-Plan:</p>
<p>Schritt 1: Projektinitialisierung und Architektur festlegen</p>
<p>Zunächst wird die Basis für die Mobile-App geschaffen. Dies umfasst die Auswahl des Tech-Stacks, das Aufsetzen des Projekts und das Sicherstellen der Kompatibilität mit der bestehenden SmolDesk-Infrastruktur.</p>
<p>Aufgaben in Schritt 1:</p>
<p>React Native einrichten: Initialisiere ein neues React-Native-Projekt (z.B. mit npx react-native init SmolDeskMobile). Richte die Entwicklungsumgebung für Android ein (Android Studio, SDK) und später für iOS (Xcode). Lege eine modulare Projektstruktur an (z.B. Separate Verzeichnisse für Components, Screens, Services etc.).</p>
<p>Abhängigkeiten hinzufügen: Installiere zentrale Bibliotheken: insbesondere eine WebRTC-Bibliothek für React Native (z.B. react-native-webrtc) zur Peer-to-Peer Kommunikation. Diese ermöglicht der App, Video-/Audio-Streams über WebRTC zu empfangen und zu senden – fundamental für SmolDesk’s Streaming-Architektur. Weitere Abhängigkeiten: z.B. @react-navigation (für App-Navigation), UI-Library (etwa React Native Paper) und Module für spezielle Funktionen (Clipboard, Dateizugriff).</p>
<p>Architektur abstimmen: Die SmolDesk-Desktop-App besteht aus einem Rust/Tauri-Backend (für Bildschirmaufnahme und Eingabe-Injection) und einem React-Frontend sowie einem Node.js Signaling-Server für WebRTC. Plane die Mobile-App als Client, der sich mit dem bestehenden Signaling-Server verbindet und als Viewer gegenüber dem Linux-Host fungiert. Definiere Schnittstellen: z.B. URL/Adresse des Signaling-Servers konfigurierbar machen (standardmäßig z.B. wss://&lt;server-url&gt;). Die App benötigt kein eigenes Backend, sondern integriert in die vorhandene P2P-Architektur.</p>
<p>Code-Sharing prüfen: Analysiere, ob bestehende Frontend-Logik wiederverwendbar ist. SmolDesk hat z.B. einen React-Hook useSmolDesk und modulare Frontend-Komponenten für Verbindung und Streaming. Gegebenenfalls können Protokoll-Details (z.B. WebRTC-Nachrichtenformate, Signaling-Nachrichten) in die RN-App übernommen werden, um Konsistenz zu gewährleisten. Dokumentiere diese Formate aus dem bestehenden Code.</p>
<p>Schritt 2: Grundlegende Verbindung (Signaling) &amp; WebRTC-Integration</p>
<p>In diesem Schritt steht die Kernfunktion – die Verbindung zum Remote-Desktop – im Vordergrund. Die App muss dem Benutzer ermöglichen, eine Session aufzubauen, was das Zusammenspiel von Signaling-Server und WebRTC-Peer-Verbindung erfordert.</p>
<p>Aufgaben in Schritt 2:</p>
<p>UI für Verbindungsaufbau: Implementiere einen Startbildschirm mit Eingabemöglichkeit für Verbindungsdaten. Beispielsweise können Benutzer eine Sitzungs-ID oder einen Code eingeben, um sich mit dem Host zu verbinden (analog zur Desktop-App, die Room Creation/Joining unterstützt). Alternativ könnte ein QR-Code-Scan in Erwägung gezogen werden (Host generiert QR mit Verbindungsdetails).</p>
<p>Signaling via WebSocket: Integriere die Verbindung zum SmolDesk Signaling-Server (Node.js). Verwende z.B. react-native-websocket oder die WebSocket-API von React Native, um eine Verbindung aufzubauen. Implementiere das Signaling-Protokoll identisch zur Desktop-Variante: Austausch von SDP-Angebot/Antwort und ICE-Kandidaten über den Server, um die WebRTC-Verbindung zwischen Mobilgerät und Host auszuhandeln. Stelle sicher, dass die Mobile-App sich als „Viewer“ korrekt beim Server registriert und einem Raum beitritt.</p>
<p>WebRTC PeerConnection aufbauen: Nutze react-native-webrtc, um einen PeerConnection zu erstellen, sobald Signaling abgeschlossen ist. Führe peerConnection.setRemoteDescription mit dem vom Host erhaltenen SDP aus und sende dein Angebot/Antwort entsprechend zurück. Konfiguriere die ICE-Server (STUN/TURN) genauso wie in SmolDesk, sodass auch Verbindungen hinter NAT reibungslos funktionieren.</p>
<p>Video-Stream empfangen: Füge einen Listener hinzu, der auf peerConnection.ontrack reagiert. Der Host sendet den Bildschirm als Video-Stream; die Mobile-App sollte diesen Stream empfangen und anzeigen. Verwende dazu in RN den bereitgestellten <code>&lt;RTCView /&gt;</code> (oder ähnliches) Component, um den eingehenden Videostream darzustellen. Sorge dafür, dass der Videostream im Vollbild oder an den Bildschirm des Geräts angepasst angezeigt wird (mit Zoom-/Scroll-Möglichkeit für große Desktops). Hinweis: SmolDesk unterstützt verschiedene Video-Codecs (H.264, VP8/VP9, AV1) – stelle sicher, dass die mobilen WebRTC-Bibliotheken diese decodieren können (moderne Geräte unterstützen H.264 hardwarebeschleunigt).</p>
<p>Audio-Stream (optional): Falls SmolDesk Audio-Streaming implementiert oder plant, konfiguriere auch einen Audio-Track. Erlaube der App, den Audio-Track des Remote-PCs wiederzugeben (unter Beachtung der Lautstärkeeinstellungen des Phones). Prüfe, ob für Audio ein Nutzerbefehl nötig ist (manche Plattformen verlangen Interaktion, bevor Audio autoplay funktioniert).</p>
<p>Nach diesem Schritt sollte die App in der Lage sein, sich mit einem Host zu verbinden und dessen Bildschirm in Echtzeit anzuzeigen. Die Latenz sollte dabei möglichst gering sein (SmolDesk strebt &lt;200 ms an); teste dies in einem lokalen Netzwerk und optimiere ggf. P2P-Einstellungen.</p>
<p>Schritt 3: Remote-Bildschirm anzeigen &amp; mobile UI optimieren</p>
<p>Nun steht die Benutzeroberfläche und Nutzererfahrung im Fokus, insbesondere für das Betrachten des Remote-Desktops auf einem kleinen Bildschirm. Hier geht es darum, die Anzeige anzupassen und mobile Interaktionen zu ermöglichen.</p>
<p>Aufgaben in Schritt 3:</p>
<p>Bildschirm-Viewer UI: Entwickle einen dedizierten Screen in der App (z.B. RemoteDesktopScreen), der den laufenden Videostream anzeigt. Ergänze Bedienelemente wie z.B. eine Leiste oder halbtransparente Buttons für essenzielle Aktionen (Verbindung trennen, Tastatur einblenden, evtl. Monitor wechseln). Stelle sicher, dass diese Controls die Sicht auf den Remote-Bildschirm nicht dauerhaft verdecken (einblendbar per Tap).</p>
<p>Skalierung und Rotation: Implementiere Zoom- und Scroll-Funktionen für die Bildschirmansicht. Da Desktop-Auflösungen größer als Handybildschirme sind, soll der Nutzer via Pinch-to-Zoom in den Remote-Screen hineinzoomen können. Erlaube Draggen mit zwei Fingern, um bei vergrößerter Ansicht zu verschieben. Unterstütze außerdem Landscape-Modus – viele Benutzer werden ihr Gerät quer halten, um mehr vom Remote-Bild zu sehen. Teste die Darstellung bei verschiedenen Displaygrößen und Ausrichtungen.</p>
<p>Verbindungsstatus-Anzeige: Integriere visuelles Feedback für die Verbindung. Beispielsweise ein Status-Indicator oder Toast-Meldungen („Verbinde...“, „Verbunden“, „Verbindung verloren – Reconnect...“). SmolDesk enthält bereits Monitoring für Verbindungsqualität – eine vereinfachte Anzeige der Latenz oder Qualität (z.B. Balken) könnte dem User helfen.</p>
<p>Mobil-optimierte Navigation: Falls die App mehrere Bildschirme hat (z.B. Start/Connect, Settings, Viewer), setze eine Navigation ein, die Touch-optimiert ist. Z.B. eine Bottom-Tab-Navigation für Hauptbereiche (falls sinnvoll), oder modale Popups für Einstellungen während einer Session. Der Fokus der App liegt aber vermutlich hauptsächlich auf dem Viewer, sodass die Navigation einfach gehalten werden kann.</p>
<p>Schritt 4: Eingabesteuerung (Maus &amp; Tastatur) via Touch umsetzen</p>
<p>Ein Kernfeature von SmolDesk ist die Fernsteuerung der Maus und Tastatur des entfernten Linux-PCs. Die Mobile-App muss Touch-Ereignisse in Mausbewegungen/-klicks und Tastatureingaben umsetzen, damit der Nutzer den Remote-Desktop voll steuern kann.</p>
<p>Aufgaben in Schritt 4:</p>
<p>Touch -&gt; Maus Mapping: Entwickle ein System, um Touch-Gesten in Maussteuerung umzusetzen. Übliche Ansätze: Direktes Tap auf den Remote-Bildschirm erzeugt einen Mausklick an entsprechender Position, Langdruck könnte einen Rechtsklick senden. Ein einzelner Finger-Drag ohne Zoom (bzw. im speziellen Steuerungsmodus) bewegt die Remote-Maus (relative Bewegung). Im Vergleich zum Desktop-Client (der physische Mausbewegungen hat) muss auf Mobile evtl. zwischen Zeiger-Modus und Scroll-Modus umgeschaltet werden. Implementiere ggf. einen Toggle-Button: z.B. „Mauszeiger bewegen“ vs. „Bild verschieben“, um Konflikte zwischen Scrollen des Viewers und Bewegen des Remote-Cursors zu vermeiden.</p>
<p>Multi-Touch Gesten: Nutze zwei-Finger-Gesten für sekundäre Aktionen: z.B. Zwei-Finger-Tap = Rechtsklick (Alternative zu Langdruck), Zwei-Finger-Drag = Scrollrad (für vertikales Scrollen auf dem Remote-PC). Diese Gesten verbessern die Nutzbarkeit, da typische Remote-Desktop-Apps ähnliche Bedienkonzepte nutzen.</p>
<p>Tastatur-Eingabe: Implementiere eine Möglichkeit, Texteingaben an den Remote-PC zu senden. Biete im UI einen Tastatur Button, der die native Bildschirmtastatur öffnet. Erfasse die Eingaben und sende die Tastendrücke als Keyboard-Events über die WebRTC-Datenkanäle an den Host. SmolDesk unterstützt bereits Tastatur-Forwarding inkl. Sondertasten – stelle sicher, dass auch Modifikator-Tasten wie Strg, Alt, Esc, etc. abgesetzt werden können. Dafür könnten in der App spezielle Buttons vorgesehen werden (z.B. ein kleines Overlay mit „Strg“, „Alt“, „Entf“ etc., die der Nutzer drücken kann, um diese an den Host zu senden).</p>
<p>Input-Security beachten: Da der Host Eingaben vom Client entgegennimmt, hat SmolDesk Sicherheitsmaßnahmen (z.B. Validierung der Eingaben). Die Mobile-App sollte diese respektieren – z.B. Limitierung, falls nötig, oder Bestätigung kritischer Aktionen. Ggf. ist das aber hauptsächlich Serverseitig gelöst. Auf Client-Seite sorge dafür, dass Eingaben nicht ungewollt gesendet werden (z.B. kein dauerhaft gedrückter virtueller Button).</p>
<p>Test der Eingabesteuerung: Prüfe die Steuerung gründlich: Bewege den Mauszeiger präzise über Icons, führe Doppelklicks aus, tippe Text in verschiedene Anwendungen. Stelle sicher, dass keine Off-by-Offset-Probleme auftreten (korrekte Positionsberechnung auch bei verschiedenen Zoomstufen und Monitor-Auflösungen). Teste Sondertasten in typischen Szenarien (z.B. STRG+C/STRG+V via mobile Buttons zur Kopie &amp; Paste, siehe Clipboard-Sync im nächsten Schritt).</p>
<p>Schritt 5: Sicherheits- und Authentifizierungsfunktionen integrieren</p>
<p>SmolDesk legt großen Wert auf Security. Die Desktop-App implementiert OAuth2 mit PKCE für Authentifizierung sowie Nachrichten-Signierung (HMAC) und Zugriffssteuerung. Die Mobile-App muss diese Sicherheitsmechanismen ebenfalls unterstützen, um Verbindungen abzusichern.</p>
<p>Aufgaben in Schritt 5:</p>
<p>OAuth2 Login-Flow: Falls SmolDesk einen Login erfordert (z.B. Anmeldung an einem Konto oder an den Host via OAuth2), implementiere diesen Flow in der App. Nutze ggf. ein OAuth2-Client-Paket oder AppAuth. Die App sollte einen Login-Bildschirm bereitstellen, wo der Nutzer auf eine Anmeldeseite geleitet wird (Browser oder WebView) und anschließend mit einem Auth-Code zurückkommt (PKCE-Code-Exchange). Speichere das erhaltene Token sicher (Secure Store) und verwende es für nachfolgende Verbindungsanfragen.</p>
<p>Token-Übergabe an Signaling: Modifiziere den Signaling-Vorgang so, dass das OAuth2-Token bzw. eine signierte Zugriffsberechtigung übermittelt wird. SmolDesk generiert signierte Raum-IDs und erwartet womöglich eine HMAC-Signatur oder Token zur Verifizierung. Stelle sicher, dass die Mobile-App im Signaling-Protokoll das Token mitgibt, damit der Host die Berechtigung prüft. Dieses Vorgehen schützt vor unbefugtem Zugriff – nur authentisierte Clients dürfen die Remote-Session starten.</p>
<p>Datenkanal-Verschlüsselung: WebRTC verschlüsselt Medienströme standardmäßig (SRTP), aber eventuell nutzt SmolDesk zusätzliche Verschlüsselung für Datenkanäle oder Messages. Falls Ende-zu-Ende Verschlüsselung für Steuerdaten vorgesehen ist (z.B. eigenständige AES-Verschlüsselung der Eingabe-Events), implementiere diese analog zur Desktop-App. Übernimm dieselben Algorithmen/Schlüsselableitungen, sodass die Mobile-App nahtlos mit dem Host kommunizieren kann.</p>
<p>App-Sicherheit &amp; Berechtigungen: Achte auch auf mobile-spezifische Sicherheitsaspekte. Fordere nur nötige Berechtigungen an (Netzwerkzugriff ist klar, evtl. Speicherzugriff für Dateitransfer, Kamera nur falls QR-Scan genutzt). Hinterlege Privacy Labels (bei iOS) und erkläre dem Nutzer, wofür Berechtigungen benötigt werden. Implementiere Schutz gegen Man-in-the-Middle im Signaling (z.B. Certificate Pinning für den Signaling-Server, falls dieser übers Internet läuft).</p>
<p>Schritt 6: Erweiterte Funktionen (Clipboard, Dateiübertragung, Multi-Monitor)</p>
<p>Nachdem die Grundfunktionalität steht, werden nun alle übrigen Features ergänzt, damit die Mobile-App funktionsgleich zur Desktop-Version ist. Insbesondere sind dies Zwischenablage-Synchronisation, Dateiübertragungen sowie Multi-Monitor-Unterstützung.</p>
<p>Aufgaben in Schritt 6:</p>
<p>Clipboard-Synchronisation: Implementiere eine bidirektionale Zwischenablage zwischen Mobile und Remote-PC. Nutze die RN-Clipboard API, um Zugriff auf die Geräte-Zwischenablage zu erhalten. Wenn der Nutzer auf dem Phone Text/Bild kopiert, sende dies über den WebRTC-Datenkanal an den Host; umgekehrt empfange vom Host Clipboard-Inhalte und aktualisiere die lokale Zwischenablage. Achte auf Format-Unterstützung: Textübertragung hat Priorität, evtl. lassen sich später Bilder oder HTML-Formate übertragen. Baue in der App ggf. eine Einstellungsoption ein, um Clipboard-Sync aus Datenschutzgründen ein-/auszuschalten.</p>
<p>Dateiübertragung: Füge die Möglichkeit hinzu, Dateien zwischen Mobilgerät und Remote-PC auszutauschen. Auf Mobile-Seite bedeutet das: z.B. einen „Datei senden“-Button im UI, der einen Datei-Browser öffnet (über RN&#x27;s DocumentPicker oder MediaLibrary). Die ausgewählte Datei wird dann via WebRTC-Datenkanal gestreamt. Implementiere auf Protokollebene eine Dateitransfer-Message mit Meta-Daten (Dateiname, Größe) und segmentiere die Datei in Blöcke, falls nötig. Ebenso unterstütze den Empfang von Dateien vom Host: Frage den Nutzer, wo die empfangene Datei gespeichert werden soll (bei Android z.B. Download-Ordner, bei iOS in einen App-spezifischen Ordner, evtl. mit der Möglichkeit via Share-Sheet zu exportieren). Zeige Fortschrittsbalken während Transfers an und implementiere eine Resume-Logik für unterbrochene Übertragungen (sofern vom Protokoll vorgesehen).</p>
<p>Multi-Monitor Support: SmolDesk unterstützt mehrere Monitore (Erkennung und Auswahl). Die Mobile-App sollte erlauben, zwischen mehreren Remote-Bildschirmen umzuschalten. Falls der Host alle Monitore gleichzeitig streamen kann, könnte der Nutzer einen auswählen; wahrscheinlicher ist, dass nur ein Stream aktiv ist und per Befehl der Monitor gewechselt wird. Implementiere im UI einen Monitor-Wechsel-Dialog – z.B. ein Icon „Monitor“ öffnet eine Liste der erkannten Monitore (mit Bezeichnungen oder Indizes). Bei Auswahl sendet die App einen Steuerbefehl an den Host, der dann den entsprechenden Monitor streamt. Aktualisiere die Anzeige entsprechend. Teste das mit einer Multi-Monitor-Setup am Host.</p>
<p>Weitere Features &amp; Feinschliff: Ergänze sonstige in der Roadmap geplante Funktionen, sofern relevant für den Client. Beispiele: Session Recording (die App könnte eine Aufnahmemöglichkeit anbieten, um den Remote-Screen als Video lokal aufzuzeichnen – optional), Anzeige von Verbindungsstatistiken (Bitrate, FPS, Latenz – zur Diagnose, möglicherweise unter einem Info-Overlay), Themes (Dark/Light-Mode Umschaltung, angepasst an Systemtheme), Internationalisierung der App-Oberfläche (falls geplant, z.B. mehrsprachige UI-Texte analog zur Desktop-Dokumentation).</p>
<p>Schritt 7: Optimierung der Benutzererfahrung (Mobile-First Feinschliff)</p>
<p>In diesem Schritt wird die App hinsichtlich Performance, Usability und Plattform-Konventionen optimiert, um eine hochwertige mobile Nutzererfahrung sicherzustellen.</p>
<p>Aufgaben in Schritt 7:</p>
<p>Performance-Tuning: Überprüfe die Performance der Videowiedergabe und Eingabeverarbeitung auf verschiedenen Geräten. Optimiere die Render- und Decode-Leistung: stelle sicher, dass die Decodierung des Video-Streams möglichst in nativer Hardware erfolgt (was i.d.R. durch WebRTC gegeben ist). Achte auf die CPU-/Speicherauslastung – SmolDesk zielte auf &lt;15% CPU bei 1080p auf modernen Systemen; auf Mobilgeräten sollten ähnliche effiziente Werte angestrebt werden. Wenn nötig, reduziere Standard-Framerate oder -Auflösung für Mobil-Clients oder implementiere adaptive Qualitätsanpassung abhängig von Netzwerk/Geräteperformance (diese Funktionalität ist teils im Backend schon vorhanden).</p>
<p>Mobil-spezifische UI/UX: Führe einen UX-Audit durch: Ist alles gut mit dem Finger bedienbar? Sind Schaltflächen groß genug und an sinnvollen Positionen (z.B. wichtige Controls eher am Bildschirmrand gut erreichbar mit dem Daumen)? Stelle sicher, dass im Hochformat die UI nicht zu gedrängt ist – evtl. bevorzugt man ohnehin Querformat während der Session, aber die App sollte beide Lagen unterstützen. Implementiere Haptisches Feedback für bestimmte Aktionen (z.B. kurze Vibration bei langem Druck = Rechtsklick, um dem Nutzer physisches Feedback zu geben). Nutze Plattform-Konventionen, z.B. auf Android einen Zurück-Button Handler (Verbindung trennen/bestätigen, statt App einfach zu beenden).</p>
<p>Stabilität &amp; Fehlerbehandlung: Verbessere die Robustheit: Fange Netzwerkfehler ab (z.B. Verbindungsverlust zum Signaling-Server oder Peer) und implementiere einen automatischen Reconnect-Mechanismus. Sollte die Verbindung abbrechen, versucht die App, neu zu verbinden, und informiert den Nutzer. Stelle sicher, dass Inkonsistenzen (z.B. kein Stream empfangen) gut gehandhabt werden – etwa durch Anzeige eines Hinweis und Option, die Session neu zu starten. Crash-Logging integrieren (z.B. Sentry oder Firebase Crashlytics), um Fehler im Feld nachverfolgen zu können.</p>
<p>Schritt 8: Testing (umfangreiche Tests auf Android)</p>
<p>Bevor die App veröffentlicht wird, muss sie intensiv getestet werden. Da zunächst Android im Fokus steht, sollten hier auf diversen Geräten Tests durchgeführt werden.</p>
<p>Aufgaben in Schritt 8:</p>
<p>Funktionale Tests: Prüfe jede Funktion manuell: Verbindungsaufbau zu einem Test-Host, Live-Video anzeigen, Maus bewegen, klicken, tippen, Clipboard sync (z.B. Text vom Handy aufs Remote-Terminal einfügen und umgekehrt), Datei senden und empfangen, Monitor wechseln, etc. Teste auch die Sicherheitsflows – z.B. ob nur mit gültigem Token verbunden werden kann, ob falsche Token abgewiesen werden.</p>
<p>Geräte- und Versionsvielfalt: Teste auf verschiedenen Android-Geräten (Smartphones, evtl. Tablets) mit unterschiedlichen Bildschirmgrößen und Android-Versionen. Achte besonders auf ältere Versionen (min. Android 8 oder 9, je nach Festlegung) sowie aktuelle Versionen. Prüfe Leistung auf schwächeren Geräten, um sicherzustellen, dass auch dort zumindest eine reduzierte Qualität noch nutzbar ist.</p>
<p>Netzwerkbedingungen simulieren: Führe Tests bei unterschiedlichen Netzwerkbedingungen durch – z.B. schnelles WLAN vs. mobiles 4G/LTE. Verwende ggf. einen Network Link Conditioner, um höhere Latenzen oder Paketverlust zu simulieren. Beobachte, ob die adaptive Qualitätssteuerung greift und die Verbindung stabil bleibt.</p>
<p>Automatisierte Tests: Wenn möglich, schreibe einige automatisierte End-to-End-Tests für Kernabläufe. Tools wie Detox (für React Native) könnten helfen, zumindest UI-Interaktionen zu testen (z.B. Navigation, Anzeige von Stream-View). Integrationstests für die Signaling- und WebRTC-Logik sind komplexer – hier ggf. auf instrumentierte Tests mit einem Dummy-WebRTC-Endpunkt setzen. Zudem Unit-Tests für Hilfsfunktionen (z.B. Formatierung von Datenpaketen) erstellen.</p>
<p>Feedback einholen: Führe eine geschlossene Beta mit einigen Nutzern durch (Google Play Beta-Channel). Sammle Feedback zur Bedienung (ist das Touch-Steuerungsschema intuitiv? irgendwelche Schwierigkeiten?). Nutze dieses Feedback, um letzte UX-Anpassungen vorzunehmen.</p>
<p>Schritt 9: Launch der Android-App (Veröffentlichung)</p>
<p>Nach erfolgreich bestandenen Tests ist die Android-App bereitzustellen. Dieser Schritt umfasst Vorbereitung der App für den Launch im Google Play Store.</p>
<p>Aufgaben in Schritt 9:</p>
<p>Build &amp; Signatur: Erstelle einen Release-Build der React Native App für Android (.apk oder .aab). Stelle sicher, dass die App mit einem Release Keystore signiert ist. Überprüfe, dass die ProGuard/Minification keine kritischen Teile strippt (insbesondere native WebRTC libraries).</p>
<p>Store-Vorbereitung: Bereite den Play Store Eintrag vor – erstelle aussagekräftige Screenshots (evtl. mit einem verbundenen Session-Bild), eine Beschreibung der App und liste die Hauptfunktionen (Remote-Desktop für Linux, sichere P2P-Verbindung, etc.). Achte darauf, die Alleinstellungsmerkmale hervorzuheben, z.B. WebRTC-P2P für niedrige Latenz, X11/Wayland Unterstützung auf Host-Seite, Open-Source etc.</p>
<p>Berechtigungserklärungen: Falls besondere Berechtigungen verwendet werden, füge im Store-Eintrag Privacy- und Permission-Hinweise hinzu (z.B. Zugriff auf Dateien für Dateitransfer). Stelle sicher, dass die App den Play Store Richtlinien entspricht. Remote-Access-Apps sind in der Regel zulässig, solange sie nicht missbräuchlich sind – betone legitime Nutzung (eigener Desktop-Zugriff).</p>
<p>Release Management: Veröffentliche die App zunächst als Beta/Stage Rollout, um evtl. letzte Probleme abzufangen. Beobachte Crash-Reports und Nutzerbewertungen, um schnell reagieren zu können. Plane Updates ein: z.B. einen Patch nach dem ersten Nutzerfeedback, falls kleinere Korrekturen nötig sind.</p>
<p>Schritt 10: Portierung auf iOS und App Store Launch</p>
<p>Nachdem die Android-Version läuft, wird die App auf iOS portiert und veröffentlicht. Dank React Native ist der Grossteil des Codes wiederverwendbar, jedoch sind einige iOS-spezifische Anpassungen nötig.</p>
<p>Aufgaben in Schritt 10:</p>
<p>iOS-Projekt einrichten: Öffne das React-Native-Projekt in Xcode und stelle sicher, dass alle notwendigen iOS-Abhängigkeiten installiert sind (Pod-Install für CocoaPods im iOS-Verzeichnis ausführen, z.B. für react-native-webrtc). Lege ein App Icon und LaunchScreen für iOS an. Konfiguriere in Xcode die App Capabilities und Entitlements (Netzwerk, evtl. Background Modes falls nötig für VoIP/WebRTC – wobei Remote Desktop vermutlich im Vordergrund läuft).</p>
<p>Plattformspezifische Anpassungen: Überprüfe die UI auf iPhone-Screens (verschiedene Größen, Notch). Passe Layouts an, wo Safe-Areas berücksichtigt werden müssen. Implementiere ggf. iOS-typische UI-Details (z.B. Nutzung der iOS Action Sheet/Stil bei bestimmten Dialogen, um den UX-Konventionen zu entsprechen). Achte darauf, dass der Zurück-Mechanismus unter iOS (Swipe-Geste oder NavigationBar) konsistent gehandhabt wird.</p>
<p>Test auf iOS-Geräten: Führe analog zu Android umfangreiche Tests auf echten iOS-Geräten durch (verschiedene iPhone-Modelle, iPad falls unterstützt). Insbesondere prüfe die WebRTC-Funktion – die Bibliothek sollte auf iOS funktionieren, teste Verbindungsaufbau, Streaming, Performance (iPhones haben i.d.R. starke Hardware, sollten 1080p Streams gut handhaben). Überprüfe Audio (iOS erfordert evtl. eine Erlaubnis in Info.plist, selbst wenn nur Audio empfangen wird – füge bei Bedarf einen NSMicrophoneUsageDescription hinzu, falls nötig für WebRTC).</p>
<p>App Store Vorbereitung: Erstelle ein iOS Release (IPA) mit korrekter Signierung (Distribution-Provisioning-Profile, Apple Developer Account). Erstelle den App Store Connect Eintrag: Beschreibungen (ggf. kann viel von Android übernommen werden), Screenshots (von einem iPhone in Aktion). Beachte, dass Apple strenge Richtlinien hat – betone die Sicherheit (OAuth2, Verschlüsselung) und legitime Nutzung. Reiche die App zur Review ein. Bei etwaigen Nachfragen (z.B. Demonstrations-Login für Review-Team bereitstellen, falls nötig) schnell reagieren.</p>
<p>Cross-Plattform Abgleich: Nach Veröffentlichung auf iOS, stelle sicher, dass die Codebasis konsistent bleibt. Nutzen beide Plattformen denselben Funktionsumfang, und eventuelle Plattformunterschiede werden via Code (conditional rendering/styling) gehandhabt. Plane die zukünftige Entwicklung so, dass neue Features gleichzeitig für beide Plattformen umgesetzt und getestet werden.</p>
<hr>
<p>Abschließend: Mit diesem Vorgehensplan wird die SmolDesk Mobile App Schritt für Schritt entwickelt. Durch die enge Anlehnung an die bestehende SmolDesk-Architektur (WebRTC-P2P, Signaling, Sicherheitsmodelle) und das Beachten aller Hauptfeatures – von Bildschirmübertragung und Eingabefernsteuerung bis zu Dateiablage und Multi-Monitor – entsteht eine vollwertige mobile Anwendung. Eine gründliche Test- und Optimierungsphase stellt sicher, dass die App performant, sicher und benutzerfreundlich ist. So wird SmolDesk künftig nicht nur auf Desktop, sondern auch auf mobilen Geräten ein hochwertiges Remote-Desktop-Erlebnis für Endnutzer bieten können.</p>
<p>Quellen: Die oben genannten Punkte basieren auf der Analyse der SmolDesk-Dokumentation und Codebasis, u.a. des SmolDesk Implementation Plans, des Implementation Status sowie weiteren Entwicklungsdokumenten, welche die Systemarchitektur und geplanten Features detailliert beschreiben. Diese Informationen gewährleisteten, dass der Entwicklungsplan alle relevanten Aspekte der SmolDesk-Plattform berücksichtigt.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/EcoSphereNetwork/SmolDesk/edit/main/docs/archive/old_docs/Smodesk-Mobile.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Diese Seite bearbeiten</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Dokumentation Seiten"></nav></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Project</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/EcoSphereNetwork/SmolDesk" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">© 2025 SmolDesk Team</div></div></div></footer></div>
</body>
</html>