"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3213],{3074:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"archive/old_docs/Smodesk-Mobile","title":"Smodesk-Mobile","description":"","source":"@site/archive/old_docs/Smodesk-Mobile.md","sourceDirName":"archive/old_docs","slug":"/archive/old_docs/Smodesk-Mobile","permalink":"/SmolDesk/en/archive/old_docs/Smodesk-Mobile","draft":false,"unlisted":false,"editUrl":"https://github.com/EcoSphereNetwork/SmolDesk/edit/main/docs/archive/old_docs/Smodesk-Mobile.md","tags":[],"version":"current","frontMatter":{"title":"Smodesk-Mobile","description":""}}');var r=i(4848),s=i(8453);const a={title:"Smodesk-Mobile",description:""},d=void 0,o={},l=[];function u(e){const n={blockquote:"blockquote",code:"code",hr:"hr",p:"p",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["\u26a0\ufe0f Diese Datei wurde archiviert. Die aktuelle Version befindet sich unter ",(0,r.jsx)(n.code,{children:"docs/development/setup-android.md"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Ziel: Entwicklung einer plattform\xfcbergreifenden React Native App (Android zuerst, danach iOS) f\xfcr SmolDesk, die alle Funktionen der Desktop-Version unterst\xfctzt. SmolDesk ist eine WebRTC-basierte Remote-Desktop-L\xf6sung f\xfcr Linux mit Fokus auf niedriger Latenz und Sicherheit. Die Mobile-App richtet sich an Endnutzer und soll mobile-first optimiert sein (intuitive Touch-Bedienung, responsives UI etc.). Im Folgenden ein detaillierter Schritt-f\xfcr-Schritt-Plan:"}),"\n",(0,r.jsx)(n.p,{children:"Schritt\xa01: Projektinitialisierung und Architektur festlegen"}),"\n",(0,r.jsx)(n.p,{children:"Zun\xe4chst wird die Basis f\xfcr die Mobile-App geschaffen. Dies umfasst die Auswahl des Tech-Stacks, das Aufsetzen des Projekts und das Sicherstellen der Kompatibilit\xe4t mit der bestehenden SmolDesk-Infrastruktur."}),"\n",(0,r.jsx)(n.p,{children:"Aufgaben in Schritt\xa01:"}),"\n",(0,r.jsx)(n.p,{children:"React\xa0Native einrichten: Initialisiere ein neues React-Native-Projekt (z.B. mit npx react-native init SmolDeskMobile). Richte die Entwicklungsumgebung f\xfcr Android ein (Android Studio, SDK) und sp\xe4ter f\xfcr iOS (Xcode). Lege eine modulare Projektstruktur an (z.B. Separate Verzeichnisse f\xfcr Components, Screens, Services etc.)."}),"\n",(0,r.jsx)(n.p,{children:"Abh\xe4ngigkeiten hinzuf\xfcgen: Installiere zentrale Bibliotheken: insbesondere eine WebRTC-Bibliothek f\xfcr React Native (z.B. react-native-webrtc) zur Peer-to-Peer Kommunikation. Diese erm\xf6glicht der App, Video-/Audio-Streams \xfcber WebRTC zu empfangen und zu senden \u2013 fundamental f\xfcr SmolDesk\u2019s Streaming-Architektur. Weitere Abh\xe4ngigkeiten: z.B. @react-navigation (f\xfcr App-Navigation), UI-Library (etwa\xa0React Native Paper) und Module f\xfcr spezielle Funktionen (Clipboard, Dateizugriff)."}),"\n",(0,r.jsx)(n.p,{children:"Architektur abstimmen: Die SmolDesk-Desktop-App besteht aus einem Rust/Tauri-Backend (f\xfcr Bildschirmaufnahme und Eingabe-Injection) und einem React-Frontend sowie einem Node.js Signaling-Server f\xfcr WebRTC. Plane die Mobile-App als Client, der sich mit dem bestehenden Signaling-Server verbindet und als Viewer gegen\xfcber dem Linux-Host fungiert. Definiere Schnittstellen: z.B. URL/Adresse des Signaling-Servers konfigurierbar machen (standardm\xe4\xdfig z.B. wss://<server-url>). Die App ben\xf6tigt kein eigenes Backend, sondern integriert in die vorhandene P2P-Architektur."}),"\n",(0,r.jsx)(n.p,{children:"Code-Sharing pr\xfcfen: Analysiere, ob bestehende Frontend-Logik wiederverwendbar ist. SmolDesk hat z.B. einen React-Hook useSmolDesk und modulare Frontend-Komponenten f\xfcr Verbindung und Streaming. Gegebenenfalls k\xf6nnen Protokoll-Details (z.B. WebRTC-Nachrichtenformate, Signaling-Nachrichten) in die RN-App \xfcbernommen werden, um Konsistenz zu gew\xe4hrleisten. Dokumentiere diese Formate aus dem bestehenden Code."}),"\n",(0,r.jsx)(n.p,{children:"Schritt\xa02: Grundlegende Verbindung (Signaling) & WebRTC-Integration"}),"\n",(0,r.jsx)(n.p,{children:"In diesem Schritt steht die Kernfunktion \u2013 die Verbindung zum Remote-Desktop \u2013 im Vordergrund. Die App muss dem Benutzer erm\xf6glichen, eine Session aufzubauen, was das Zusammenspiel von Signaling-Server und WebRTC-Peer-Verbindung erfordert."}),"\n",(0,r.jsx)(n.p,{children:"Aufgaben in Schritt\xa02:"}),"\n",(0,r.jsx)(n.p,{children:"UI f\xfcr Verbindungsaufbau: Implementiere einen Startbildschirm mit Eingabem\xf6glichkeit f\xfcr Verbindungsdaten. Beispielsweise k\xf6nnen Benutzer eine Sitzungs-ID oder einen Code eingeben, um sich mit dem Host zu verbinden (analog zur Desktop-App, die Room Creation/Joining unterst\xfctzt). Alternativ k\xf6nnte ein QR-Code-Scan in Erw\xe4gung gezogen werden (Host generiert QR mit Verbindungsdetails)."}),"\n",(0,r.jsx)(n.p,{children:"Signaling via WebSocket: Integriere die Verbindung zum SmolDesk Signaling-Server (Node.js). Verwende z.B. react-native-websocket oder die WebSocket-API von React Native, um eine Verbindung aufzubauen. Implementiere das Signaling-Protokoll identisch zur Desktop-Variante: Austausch von SDP-Angebot/Antwort und ICE-Kandidaten \xfcber den Server, um die WebRTC-Verbindung zwischen Mobilger\xe4t und Host auszuhandeln. Stelle sicher, dass die Mobile-App sich als \u201eViewer\u201c korrekt beim Server registriert und einem Raum beitritt."}),"\n",(0,r.jsx)(n.p,{children:"WebRTC PeerConnection aufbauen: Nutze react-native-webrtc, um einen PeerConnection zu erstellen, sobald Signaling abgeschlossen ist. F\xfchre peerConnection.setRemoteDescription mit dem vom Host erhaltenen SDP aus und sende dein Angebot/Antwort entsprechend zur\xfcck. Konfiguriere die ICE-Server (STUN/TURN) genauso wie in SmolDesk, sodass auch Verbindungen hinter NAT reibungslos funktionieren."}),"\n",(0,r.jsxs)(n.p,{children:["Video-Stream empfangen: F\xfcge einen Listener hinzu, der auf peerConnection.ontrack reagiert. Der Host sendet den Bildschirm als Video-Stream; die Mobile-App sollte diesen Stream empfangen und anzeigen. Verwende dazu in RN den bereitgestellten ",(0,r.jsx)(n.code,{children:"<RTCView />"})," (oder \xe4hnliches) Component, um den eingehenden Videostream darzustellen. Sorge daf\xfcr, dass der Videostream im Vollbild oder an den Bildschirm des Ger\xe4ts angepasst angezeigt wird (mit Zoom-/Scroll-M\xf6glichkeit f\xfcr gro\xdfe Desktops). Hinweis: SmolDesk unterst\xfctzt verschiedene Video-Codecs (H.264, VP8/VP9, AV1) \u2013 stelle sicher, dass die mobilen WebRTC-Bibliotheken diese decodieren k\xf6nnen (moderne Ger\xe4te unterst\xfctzen H.264 hardwarebeschleunigt)."]}),"\n",(0,r.jsx)(n.p,{children:"Audio-Stream (optional): Falls SmolDesk Audio-Streaming implementiert oder plant, konfiguriere auch einen Audio-Track. Erlaube der App, den Audio-Track des Remote-PCs wiederzugeben (unter Beachtung der Lautst\xe4rkeeinstellungen des Phones). Pr\xfcfe, ob f\xfcr Audio ein Nutzerbefehl n\xf6tig ist (manche Plattformen verlangen Interaktion, bevor Audio autoplay funktioniert)."}),"\n",(0,r.jsx)(n.p,{children:"Nach diesem Schritt sollte die App in der Lage sein, sich mit einem Host zu verbinden und dessen Bildschirm in Echtzeit anzuzeigen. Die Latenz sollte dabei m\xf6glichst gering sein (SmolDesk strebt <200\xa0ms an); teste dies in einem lokalen Netzwerk und optimiere ggf. P2P-Einstellungen."}),"\n",(0,r.jsx)(n.p,{children:"Schritt\xa03: Remote-Bildschirm anzeigen & mobile UI optimieren"}),"\n",(0,r.jsx)(n.p,{children:"Nun steht die Benutzeroberfl\xe4che und Nutzererfahrung im Fokus, insbesondere f\xfcr das Betrachten des Remote-Desktops auf einem kleinen Bildschirm. Hier geht es darum, die Anzeige anzupassen und mobile Interaktionen zu erm\xf6glichen."}),"\n",(0,r.jsx)(n.p,{children:"Aufgaben in Schritt\xa03:"}),"\n",(0,r.jsx)(n.p,{children:"Bildschirm-Viewer UI: Entwickle einen dedizierten Screen in der App (z.B. RemoteDesktopScreen), der den laufenden Videostream anzeigt. Erg\xe4nze Bedienelemente wie z.B. eine Leiste oder halbtransparente Buttons f\xfcr essenzielle Aktionen (Verbindung trennen, Tastatur einblenden, evtl. Monitor wechseln). Stelle sicher, dass diese Controls die Sicht auf den Remote-Bildschirm nicht dauerhaft verdecken (einblendbar per Tap)."}),"\n",(0,r.jsx)(n.p,{children:"Skalierung und Rotation: Implementiere Zoom- und Scroll-Funktionen f\xfcr die Bildschirmansicht. Da Desktop-Aufl\xf6sungen gr\xf6\xdfer als Handybildschirme sind, soll der Nutzer via Pinch-to-Zoom in den Remote-Screen hineinzoomen k\xf6nnen. Erlaube Draggen mit zwei Fingern, um bei vergr\xf6\xdferter Ansicht zu verschieben. Unterst\xfctze au\xdferdem Landscape-Modus \u2013 viele Benutzer werden ihr Ger\xe4t quer halten, um mehr vom Remote-Bild zu sehen. Teste die Darstellung bei verschiedenen Displaygr\xf6\xdfen und Ausrichtungen."}),"\n",(0,r.jsx)(n.p,{children:"Verbindungsstatus-Anzeige: Integriere visuelles Feedback f\xfcr die Verbindung. Beispielsweise ein Status-Indicator oder Toast-Meldungen (\u201eVerbinde...\u201c, \u201eVerbunden\u201c, \u201eVerbindung verloren \u2013 Reconnect...\u201c). SmolDesk enth\xe4lt bereits Monitoring f\xfcr Verbindungsqualit\xe4t \u2013 eine vereinfachte Anzeige der Latenz oder Qualit\xe4t (z.B. Balken) k\xf6nnte dem User helfen."}),"\n",(0,r.jsx)(n.p,{children:"Mobil-optimierte Navigation: Falls die App mehrere Bildschirme hat (z.B. Start/Connect, Settings, Viewer), setze eine Navigation ein, die Touch-optimiert ist. Z.B. eine Bottom-Tab-Navigation f\xfcr Hauptbereiche (falls sinnvoll), oder modale Popups f\xfcr Einstellungen w\xe4hrend einer Session. Der Fokus der App liegt aber vermutlich haupts\xe4chlich auf dem Viewer, sodass die Navigation einfach gehalten werden kann."}),"\n",(0,r.jsx)(n.p,{children:"Schritt\xa04: Eingabesteuerung (Maus & Tastatur) via Touch umsetzen"}),"\n",(0,r.jsx)(n.p,{children:"Ein Kernfeature von SmolDesk ist die Fernsteuerung der Maus und Tastatur des entfernten Linux-PCs. Die Mobile-App muss Touch-Ereignisse in Mausbewegungen/-klicks und Tastatureingaben umsetzen, damit der Nutzer den Remote-Desktop voll steuern kann."}),"\n",(0,r.jsx)(n.p,{children:"Aufgaben in Schritt\xa04:"}),"\n",(0,r.jsx)(n.p,{children:"Touch -> Maus Mapping: Entwickle ein System, um Touch-Gesten in Maussteuerung umzusetzen. \xdcbliche Ans\xe4tze: Direktes Tap auf den Remote-Bildschirm erzeugt einen Mausklick an entsprechender Position, Langdruck k\xf6nnte einen Rechtsklick senden. Ein einzelner Finger-Drag ohne Zoom (bzw. im speziellen Steuerungsmodus) bewegt die Remote-Maus (relative Bewegung). Im Vergleich zum Desktop-Client (der physische Mausbewegungen hat) muss auf Mobile evtl. zwischen Zeiger-Modus und Scroll-Modus umgeschaltet werden. Implementiere ggf. einen Toggle-Button: z.B. \u201eMauszeiger bewegen\u201c vs. \u201eBild verschieben\u201c, um Konflikte zwischen Scrollen des Viewers und Bewegen des Remote-Cursors zu vermeiden."}),"\n",(0,r.jsx)(n.p,{children:"Multi-Touch Gesten: Nutze zwei-Finger-Gesten f\xfcr sekund\xe4re Aktionen: z.B. Zwei-Finger-Tap = Rechtsklick (Alternative zu Langdruck), Zwei-Finger-Drag = Scrollrad (f\xfcr vertikales Scrollen auf dem Remote-PC). Diese Gesten verbessern die Nutzbarkeit, da typische Remote-Desktop-Apps \xe4hnliche Bedienkonzepte nutzen."}),"\n",(0,r.jsx)(n.p,{children:"Tastatur-Eingabe: Implementiere eine M\xf6glichkeit, Texteingaben an den Remote-PC zu senden. Biete im UI einen Tastatur Button, der die native Bildschirmtastatur \xf6ffnet. Erfasse die Eingaben und sende die Tastendr\xfccke als Keyboard-Events \xfcber die WebRTC-Datenkan\xe4le an den Host. SmolDesk unterst\xfctzt bereits Tastatur-Forwarding inkl. Sondertasten \u2013 stelle sicher, dass auch Modifikator-Tasten wie Strg, Alt, Esc, etc. abgesetzt werden k\xf6nnen. Daf\xfcr k\xf6nnten in der App spezielle Buttons vorgesehen werden (z.B. ein kleines Overlay mit \u201eStrg\u201c, \u201eAlt\u201c, \u201eEntf\u201c etc., die der Nutzer dr\xfccken kann, um diese an den Host zu senden)."}),"\n",(0,r.jsx)(n.p,{children:"Input-Security beachten: Da der Host Eingaben vom Client entgegennimmt, hat SmolDesk Sicherheitsma\xdfnahmen (z.B. Validierung der Eingaben). Die Mobile-App sollte diese respektieren \u2013 z.B. Limitierung, falls n\xf6tig, oder Best\xe4tigung kritischer Aktionen. Ggf. ist das aber haupts\xe4chlich Serverseitig gel\xf6st. Auf Client-Seite sorge daf\xfcr, dass Eingaben nicht ungewollt gesendet werden (z.B. kein dauerhaft gedr\xfcckter virtueller Button)."}),"\n",(0,r.jsx)(n.p,{children:"Test der Eingabesteuerung: Pr\xfcfe die Steuerung gr\xfcndlich: Bewege den Mauszeiger pr\xe4zise \xfcber Icons, f\xfchre Doppelklicks aus, tippe Text in verschiedene Anwendungen. Stelle sicher, dass keine Off-by-Offset-Probleme auftreten (korrekte Positionsberechnung auch bei verschiedenen Zoomstufen und Monitor-Aufl\xf6sungen). Teste Sondertasten in typischen Szenarien (z.B. STRG+C/STRG+V via mobile Buttons zur Kopie & Paste, siehe Clipboard-Sync im n\xe4chsten Schritt)."}),"\n",(0,r.jsx)(n.p,{children:"Schritt\xa05: Sicherheits- und Authentifizierungsfunktionen integrieren"}),"\n",(0,r.jsx)(n.p,{children:"SmolDesk legt gro\xdfen Wert auf Security. Die Desktop-App implementiert OAuth2 mit PKCE f\xfcr Authentifizierung sowie Nachrichten-Signierung (HMAC) und Zugriffssteuerung. Die Mobile-App muss diese Sicherheitsmechanismen ebenfalls unterst\xfctzen, um Verbindungen abzusichern."}),"\n",(0,r.jsx)(n.p,{children:"Aufgaben in Schritt\xa05:"}),"\n",(0,r.jsx)(n.p,{children:"OAuth2 Login-Flow: Falls SmolDesk einen Login erfordert (z.B. Anmeldung an einem Konto oder an den Host via OAuth2), implementiere diesen Flow in der App. Nutze ggf. ein OAuth2-Client-Paket oder AppAuth. Die App sollte einen Login-Bildschirm bereitstellen, wo der Nutzer auf eine Anmeldeseite geleitet wird (Browser oder WebView) und anschlie\xdfend mit einem Auth-Code zur\xfcckkommt (PKCE-Code-Exchange). Speichere das erhaltene Token sicher (Secure Store) und verwende es f\xfcr nachfolgende Verbindungsanfragen."}),"\n",(0,r.jsx)(n.p,{children:"Token-\xdcbergabe an Signaling: Modifiziere den Signaling-Vorgang so, dass das OAuth2-Token bzw. eine signierte Zugriffsberechtigung \xfcbermittelt wird. SmolDesk generiert signierte Raum-IDs und erwartet wom\xf6glich eine HMAC-Signatur oder Token zur Verifizierung. Stelle sicher, dass die Mobile-App im Signaling-Protokoll das Token mitgibt, damit der Host die Berechtigung pr\xfcft. Dieses Vorgehen sch\xfctzt vor unbefugtem Zugriff \u2013 nur authentisierte Clients d\xfcrfen die Remote-Session starten."}),"\n",(0,r.jsx)(n.p,{children:"Datenkanal-Verschl\xfcsselung: WebRTC verschl\xfcsselt Medienstr\xf6me standardm\xe4\xdfig (SRTP), aber eventuell nutzt SmolDesk zus\xe4tzliche Verschl\xfcsselung f\xfcr Datenkan\xe4le oder Messages. Falls Ende-zu-Ende Verschl\xfcsselung f\xfcr Steuerdaten vorgesehen ist (z.B. eigenst\xe4ndige AES-Verschl\xfcsselung der Eingabe-Events), implementiere diese analog zur Desktop-App. \xdcbernimm dieselben Algorithmen/Schl\xfcsselableitungen, sodass die Mobile-App nahtlos mit dem Host kommunizieren kann."}),"\n",(0,r.jsx)(n.p,{children:"App-Sicherheit & Berechtigungen: Achte auch auf mobile-spezifische Sicherheitsaspekte. Fordere nur n\xf6tige Berechtigungen an (Netzwerkzugriff ist klar, evtl. Speicherzugriff f\xfcr Dateitransfer, Kamera nur falls QR-Scan genutzt). Hinterlege Privacy Labels (bei iOS) und erkl\xe4re dem Nutzer, wof\xfcr Berechtigungen ben\xf6tigt werden. Implementiere Schutz gegen Man-in-the-Middle im Signaling (z.B. Certificate Pinning f\xfcr den Signaling-Server, falls dieser \xfcbers Internet l\xe4uft)."}),"\n",(0,r.jsx)(n.p,{children:"Schritt\xa06: Erweiterte Funktionen (Clipboard, Datei\xfcbertragung, Multi-Monitor)"}),"\n",(0,r.jsx)(n.p,{children:"Nachdem die Grundfunktionalit\xe4t steht, werden nun alle \xfcbrigen Features erg\xe4nzt, damit die Mobile-App funktionsgleich zur Desktop-Version ist. Insbesondere sind dies Zwischenablage-Synchronisation, Datei\xfcbertragungen sowie Multi-Monitor-Unterst\xfctzung."}),"\n",(0,r.jsx)(n.p,{children:"Aufgaben in Schritt\xa06:"}),"\n",(0,r.jsx)(n.p,{children:"Clipboard-Synchronisation: Implementiere eine bidirektionale Zwischenablage zwischen Mobile und Remote-PC. Nutze die RN-Clipboard API, um Zugriff auf die Ger\xe4te-Zwischenablage zu erhalten. Wenn der Nutzer auf dem Phone Text/Bild kopiert, sende dies \xfcber den WebRTC-Datenkanal an den Host; umgekehrt empfange vom Host Clipboard-Inhalte und aktualisiere die lokale Zwischenablage. Achte auf Format-Unterst\xfctzung: Text\xfcbertragung hat Priorit\xe4t, evtl. lassen sich sp\xe4ter Bilder oder HTML-Formate \xfcbertragen. Baue in der App ggf. eine Einstellungsoption ein, um Clipboard-Sync aus Datenschutzgr\xfcnden ein-/auszuschalten."}),"\n",(0,r.jsx)(n.p,{children:"Datei\xfcbertragung: F\xfcge die M\xf6glichkeit hinzu, Dateien zwischen Mobilger\xe4t und Remote-PC auszutauschen. Auf Mobile-Seite bedeutet das: z.B. einen \u201eDatei senden\u201c-Button im UI, der einen Datei-Browser \xf6ffnet (\xfcber RN's DocumentPicker oder MediaLibrary). Die ausgew\xe4hlte Datei wird dann via WebRTC-Datenkanal gestreamt. Implementiere auf Protokollebene eine Dateitransfer-Message mit Meta-Daten (Dateiname, Gr\xf6\xdfe) und segmentiere die Datei in Bl\xf6cke, falls n\xf6tig. Ebenso unterst\xfctze den Empfang von Dateien vom Host: Frage den Nutzer, wo die empfangene Datei gespeichert werden soll (bei Android z.B. Download-Ordner, bei iOS in einen App-spezifischen Ordner, evtl. mit der M\xf6glichkeit via Share-Sheet zu exportieren). Zeige Fortschrittsbalken w\xe4hrend Transfers an und implementiere eine Resume-Logik f\xfcr unterbrochene \xdcbertragungen (sofern vom Protokoll vorgesehen)."}),"\n",(0,r.jsx)(n.p,{children:"Multi-Monitor Support: SmolDesk unterst\xfctzt mehrere Monitore (Erkennung und Auswahl). Die Mobile-App sollte erlauben, zwischen mehreren Remote-Bildschirmen umzuschalten. Falls der Host alle Monitore gleichzeitig streamen kann, k\xf6nnte der Nutzer einen ausw\xe4hlen; wahrscheinlicher ist, dass nur ein Stream aktiv ist und per Befehl der Monitor gewechselt wird. Implementiere im UI einen Monitor-Wechsel-Dialog \u2013 z.B. ein Icon \u201eMonitor\u201c \xf6ffnet eine Liste der erkannten Monitore (mit Bezeichnungen oder Indizes). Bei Auswahl sendet die App einen Steuerbefehl an den Host, der dann den entsprechenden Monitor streamt. Aktualisiere die Anzeige entsprechend. Teste das mit einer Multi-Monitor-Setup am Host."}),"\n",(0,r.jsx)(n.p,{children:"Weitere Features & Feinschliff: Erg\xe4nze sonstige in der Roadmap geplante Funktionen, sofern relevant f\xfcr den Client. Beispiele: Session Recording (die App k\xf6nnte eine Aufnahmem\xf6glichkeit anbieten, um den Remote-Screen als Video lokal aufzuzeichnen \u2013 optional), Anzeige von Verbindungsstatistiken (Bitrate, FPS, Latenz \u2013 zur Diagnose, m\xf6glicherweise unter einem Info-Overlay), Themes (Dark/Light-Mode Umschaltung, angepasst an Systemtheme), Internationalisierung der App-Oberfl\xe4che (falls geplant, z.B. mehrsprachige UI-Texte analog zur Desktop-Dokumentation)."}),"\n",(0,r.jsx)(n.p,{children:"Schritt\xa07: Optimierung der Benutzererfahrung (Mobile-First Feinschliff)"}),"\n",(0,r.jsx)(n.p,{children:"In diesem Schritt wird die App hinsichtlich Performance, Usability und Plattform-Konventionen optimiert, um eine hochwertige mobile Nutzererfahrung sicherzustellen."}),"\n",(0,r.jsx)(n.p,{children:"Aufgaben in Schritt\xa07:"}),"\n",(0,r.jsx)(n.p,{children:"Performance-Tuning: \xdcberpr\xfcfe die Performance der Videowiedergabe und Eingabeverarbeitung auf verschiedenen Ger\xe4ten. Optimiere die Render- und Decode-Leistung: stelle sicher, dass die Decodierung des Video-Streams m\xf6glichst in nativer Hardware erfolgt (was i.d.R. durch WebRTC gegeben ist). Achte auf die CPU-/Speicherauslastung \u2013 SmolDesk zielte auf <15% CPU bei 1080p auf modernen Systemen; auf Mobilger\xe4ten sollten \xe4hnliche effiziente Werte angestrebt werden. Wenn n\xf6tig, reduziere Standard-Framerate oder -Aufl\xf6sung f\xfcr Mobil-Clients oder implementiere adaptive Qualit\xe4tsanpassung abh\xe4ngig von Netzwerk/Ger\xe4teperformance (diese Funktionalit\xe4t ist teils im Backend schon vorhanden)."}),"\n",(0,r.jsx)(n.p,{children:"Mobil-spezifische UI/UX: F\xfchre einen UX-Audit durch: Ist alles gut mit dem Finger bedienbar? Sind Schaltfl\xe4chen gro\xdf genug und an sinnvollen Positionen (z.B. wichtige Controls eher am Bildschirmrand gut erreichbar mit dem Daumen)? Stelle sicher, dass im Hochformat die UI nicht zu gedr\xe4ngt ist \u2013 evtl. bevorzugt man ohnehin Querformat w\xe4hrend der Session, aber die App sollte beide Lagen unterst\xfctzen. Implementiere Haptisches Feedback f\xfcr bestimmte Aktionen (z.B. kurze Vibration bei langem Druck = Rechtsklick, um dem Nutzer physisches Feedback zu geben). Nutze Plattform-Konventionen, z.B. auf Android einen Zur\xfcck-Button Handler (Verbindung trennen/best\xe4tigen, statt App einfach zu beenden)."}),"\n",(0,r.jsx)(n.p,{children:"Stabilit\xe4t & Fehlerbehandlung: Verbessere die Robustheit: Fange Netzwerkfehler ab (z.B. Verbindungsverlust zum Signaling-Server oder Peer) und implementiere einen automatischen Reconnect-Mechanismus. Sollte die Verbindung abbrechen, versucht die App, neu zu verbinden, und informiert den Nutzer. Stelle sicher, dass Inkonsistenzen (z.B. kein Stream empfangen) gut gehandhabt werden \u2013 etwa durch Anzeige eines Hinweis und Option, die Session neu zu starten. Crash-Logging integrieren (z.B. Sentry oder Firebase Crashlytics), um Fehler im Feld nachverfolgen zu k\xf6nnen."}),"\n",(0,r.jsx)(n.p,{children:"Schritt\xa08: Testing (umfangreiche Tests auf Android)"}),"\n",(0,r.jsx)(n.p,{children:"Bevor die App ver\xf6ffentlicht wird, muss sie intensiv getestet werden. Da zun\xe4chst Android im Fokus steht, sollten hier auf diversen Ger\xe4ten Tests durchgef\xfchrt werden."}),"\n",(0,r.jsx)(n.p,{children:"Aufgaben in Schritt\xa08:"}),"\n",(0,r.jsx)(n.p,{children:"Funktionale Tests: Pr\xfcfe jede Funktion manuell: Verbindungsaufbau zu einem Test-Host, Live-Video anzeigen, Maus bewegen, klicken, tippen, Clipboard sync (z.B. Text vom Handy aufs Remote-Terminal einf\xfcgen und umgekehrt), Datei senden und empfangen, Monitor wechseln, etc. Teste auch die Sicherheitsflows \u2013 z.B. ob nur mit g\xfcltigem Token verbunden werden kann, ob falsche Token abgewiesen werden."}),"\n",(0,r.jsx)(n.p,{children:"Ger\xe4te- und Versionsvielfalt: Teste auf verschiedenen Android-Ger\xe4ten (Smartphones, evtl. Tablets) mit unterschiedlichen Bildschirmgr\xf6\xdfen und Android-Versionen. Achte besonders auf \xe4ltere Versionen (min. Android\xa08 oder 9, je nach Festlegung) sowie aktuelle Versionen. Pr\xfcfe Leistung auf schw\xe4cheren Ger\xe4ten, um sicherzustellen, dass auch dort zumindest eine reduzierte Qualit\xe4t noch nutzbar ist."}),"\n",(0,r.jsx)(n.p,{children:"Netzwerkbedingungen simulieren: F\xfchre Tests bei unterschiedlichen Netzwerkbedingungen durch \u2013 z.B. schnelles WLAN vs. mobiles 4G/LTE. Verwende ggf. einen Network Link Conditioner, um h\xf6here Latenzen oder Paketverlust zu simulieren. Beobachte, ob die adaptive Qualit\xe4tssteuerung greift und die Verbindung stabil bleibt."}),"\n",(0,r.jsx)(n.p,{children:"Automatisierte Tests: Wenn m\xf6glich, schreibe einige automatisierte End-to-End-Tests f\xfcr Kernabl\xe4ufe. Tools wie Detox (f\xfcr React Native) k\xf6nnten helfen, zumindest UI-Interaktionen zu testen (z.B. Navigation, Anzeige von Stream-View). Integrationstests f\xfcr die Signaling- und WebRTC-Logik sind komplexer \u2013 hier ggf. auf instrumentierte Tests mit einem Dummy-WebRTC-Endpunkt setzen. Zudem Unit-Tests f\xfcr Hilfsfunktionen (z.B. Formatierung von Datenpaketen) erstellen."}),"\n",(0,r.jsx)(n.p,{children:"Feedback einholen: F\xfchre eine geschlossene Beta mit einigen Nutzern durch (Google Play Beta-Channel). Sammle Feedback zur Bedienung (ist das Touch-Steuerungsschema intuitiv? irgendwelche Schwierigkeiten?). Nutze dieses Feedback, um letzte UX-Anpassungen vorzunehmen."}),"\n",(0,r.jsx)(n.p,{children:"Schritt\xa09: Launch der Android-App (Ver\xf6ffentlichung)"}),"\n",(0,r.jsx)(n.p,{children:"Nach erfolgreich bestandenen Tests ist die Android-App bereitzustellen. Dieser Schritt umfasst Vorbereitung der App f\xfcr den Launch im Google Play Store."}),"\n",(0,r.jsx)(n.p,{children:"Aufgaben in Schritt\xa09:"}),"\n",(0,r.jsx)(n.p,{children:"Build & Signatur: Erstelle einen Release-Build der React Native App f\xfcr Android (.apk oder .aab). Stelle sicher, dass die App mit einem Release Keystore signiert ist. \xdcberpr\xfcfe, dass die ProGuard/Minification keine kritischen Teile strippt (insbesondere native WebRTC libraries)."}),"\n",(0,r.jsx)(n.p,{children:"Store-Vorbereitung: Bereite den Play Store Eintrag vor \u2013 erstelle aussagekr\xe4ftige Screenshots (evtl. mit einem verbundenen Session-Bild), eine Beschreibung der App und liste die Hauptfunktionen (Remote-Desktop f\xfcr Linux, sichere P2P-Verbindung, etc.). Achte darauf, die Alleinstellungsmerkmale hervorzuheben, z.B. WebRTC-P2P f\xfcr niedrige Latenz, X11/Wayland Unterst\xfctzung auf Host-Seite, Open-Source etc."}),"\n",(0,r.jsx)(n.p,{children:"Berechtigungserkl\xe4rungen: Falls besondere Berechtigungen verwendet werden, f\xfcge im Store-Eintrag Privacy- und Permission-Hinweise hinzu (z.B. Zugriff auf Dateien f\xfcr Dateitransfer). Stelle sicher, dass die App den Play Store Richtlinien entspricht. Remote-Access-Apps sind in der Regel zul\xe4ssig, solange sie nicht missbr\xe4uchlich sind \u2013 betone legitime Nutzung (eigener Desktop-Zugriff)."}),"\n",(0,r.jsx)(n.p,{children:"Release Management: Ver\xf6ffentliche die App zun\xe4chst als Beta/Stage Rollout, um evtl. letzte Probleme abzufangen. Beobachte Crash-Reports und Nutzerbewertungen, um schnell reagieren zu k\xf6nnen. Plane Updates ein: z.B. einen Patch nach dem ersten Nutzerfeedback, falls kleinere Korrekturen n\xf6tig sind."}),"\n",(0,r.jsx)(n.p,{children:"Schritt\xa010: Portierung auf iOS und App\xa0Store Launch"}),"\n",(0,r.jsx)(n.p,{children:"Nachdem die Android-Version l\xe4uft, wird die App auf iOS portiert und ver\xf6ffentlicht. Dank React Native ist der Grossteil des Codes wiederverwendbar, jedoch sind einige iOS-spezifische Anpassungen n\xf6tig."}),"\n",(0,r.jsx)(n.p,{children:"Aufgaben in Schritt\xa010:"}),"\n",(0,r.jsx)(n.p,{children:"iOS-Projekt einrichten: \xd6ffne das React-Native-Projekt in Xcode und stelle sicher, dass alle notwendigen iOS-Abh\xe4ngigkeiten installiert sind (Pod-Install f\xfcr CocoaPods im iOS-Verzeichnis ausf\xfchren, z.B. f\xfcr react-native-webrtc). Lege ein App Icon und LaunchScreen f\xfcr iOS an. Konfiguriere in Xcode die App Capabilities und Entitlements (Netzwerk, evtl. Background Modes falls n\xf6tig f\xfcr VoIP/WebRTC \u2013 wobei Remote Desktop vermutlich im Vordergrund l\xe4uft)."}),"\n",(0,r.jsx)(n.p,{children:"Plattformspezifische Anpassungen: \xdcberpr\xfcfe die UI auf iPhone-Screens (verschiedene Gr\xf6\xdfen, Notch). Passe Layouts an, wo Safe-Areas ber\xfccksichtigt werden m\xfcssen. Implementiere ggf. iOS-typische UI-Details (z.B. Nutzung der iOS Action Sheet/Stil bei bestimmten Dialogen, um den UX-Konventionen zu entsprechen). Achte darauf, dass der Zur\xfcck-Mechanismus unter iOS (Swipe-Geste oder NavigationBar) konsistent gehandhabt wird."}),"\n",(0,r.jsx)(n.p,{children:"Test auf iOS-Ger\xe4ten: F\xfchre analog zu Android umfangreiche Tests auf echten iOS-Ger\xe4ten durch (verschiedene iPhone-Modelle, iPad falls unterst\xfctzt). Insbesondere pr\xfcfe die WebRTC-Funktion \u2013 die Bibliothek sollte auf iOS funktionieren, teste Verbindungsaufbau, Streaming, Performance (iPhones haben i.d.R. starke Hardware, sollten 1080p Streams gut handhaben). \xdcberpr\xfcfe Audio (iOS erfordert evtl. eine Erlaubnis in Info.plist, selbst wenn nur Audio empfangen wird \u2013 f\xfcge bei Bedarf einen NSMicrophoneUsageDescription hinzu, falls n\xf6tig f\xfcr WebRTC)."}),"\n",(0,r.jsx)(n.p,{children:"App Store Vorbereitung: Erstelle ein iOS Release (IPA) mit korrekter Signierung (Distribution-Provisioning-Profile, Apple Developer Account). Erstelle den App Store Connect Eintrag: Beschreibungen (ggf. kann viel von Android \xfcbernommen werden), Screenshots (von einem iPhone in Aktion). Beachte, dass Apple strenge Richtlinien hat \u2013 betone die Sicherheit (OAuth2, Verschl\xfcsselung) und legitime Nutzung. Reiche die App zur Review ein. Bei etwaigen Nachfragen (z.B. Demonstrations-Login f\xfcr Review-Team bereitstellen, falls n\xf6tig) schnell reagieren."}),"\n",(0,r.jsx)(n.p,{children:"Cross-Plattform Abgleich: Nach Ver\xf6ffentlichung auf iOS, stelle sicher, dass die Codebasis konsistent bleibt. Nutzen beide Plattformen denselben Funktionsumfang, und eventuelle Plattformunterschiede werden via Code (conditional rendering/styling) gehandhabt. Plane die zuk\xfcnftige Entwicklung so, dass neue Features gleichzeitig f\xfcr beide Plattformen umgesetzt und getestet werden."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:"Abschlie\xdfend: Mit diesem Vorgehensplan wird die SmolDesk\xa0Mobile App Schritt f\xfcr Schritt entwickelt. Durch die enge Anlehnung an die bestehende SmolDesk-Architektur (WebRTC-P2P, Signaling, Sicherheitsmodelle) und das Beachten aller Hauptfeatures \u2013 von Bildschirm\xfcbertragung und Eingabefernsteuerung bis zu Dateiablage und Multi-Monitor \u2013 entsteht eine vollwertige mobile Anwendung. Eine gr\xfcndliche Test- und Optimierungsphase stellt sicher, dass die App performant, sicher und benutzerfreundlich ist. So wird SmolDesk k\xfcnftig nicht nur auf Desktop, sondern auch auf mobilen Ger\xe4ten ein hochwertiges Remote-Desktop-Erlebnis f\xfcr Endnutzer bieten k\xf6nnen."}),"\n",(0,r.jsx)(n.p,{children:"Quellen: Die oben genannten Punkte basieren auf der Analyse der SmolDesk-Dokumentation und Codebasis, u.a. des SmolDesk Implementation Plans, des Implementation Status sowie weiteren Entwicklungsdokumenten, welche die Systemarchitektur und geplanten Features detailliert beschreiben. Diese Informationen gew\xe4hrleisteten, dass der Entwicklungsplan alle relevanten Aspekte der SmolDesk-Plattform ber\xfccksichtigt."})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>d});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);